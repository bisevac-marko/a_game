
#include "handmade_platform.h"
#include "handmade_intrinsics.h"
#include "handmade_math.h"
#include "handmade_shared.h"
#include "handmade_light_atlas.h"
#include "handmade_memory.h"

// #include <sys/types.h>
#include <sys/mman.h>     // PROT_*, MAP_*, munmap
#include <sys/stat.h>     // stat
#include <sys/sysinfo.h>  // get_nprocs
#include <sys/wait.h>     // waitpid
#include <unistd.h>       // usleep
#include <pthread.h>      // threading
#include <dlfcn.h>        // dlopen, dlsym, dlclose
#include <time.h>         // CLOCK_MONOTONIC, clock_gettime
#include <semaphore.h>    // sem_init, sem_wait, sem_post
#include <alloca.h>       // alloca
#include <errno.h>        // errno

// NOTE(michiel): X11 Windowing
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>

#include <alsa/asoundlib.h>

// TODO(michiel): What to do with logging
#include <stdio.h>        // fprintf, stderr

#include "linux_handmade.h"

#include "linux_sound.h"
#include "linux_joystick.h"

//
// NOTE(casey): We prefer the discrete GPU in laptops where available
//
extern "C"
{
    int NvOptimusEnablement = 0x01;
    int AmdPowerXpressRequestHighPerformance = 0x01;
}

enum
{
    _NET_WM_STATE_REMOVE    = 0,
    _NET_WM_STATE_ADD       = 1,
    _NET_WM_STATE_TOGGLE    = 2
};

// TODO(michiel): write to console:
// write(1, string, size); for stdout
// write(2, string, size); for stderr
// read(0, buffer, size) to read from stdin

platform_api Platform;

global linux_state GlobalLinuxState;
global b32 GlobalSoftwareRendering;
global b32 GlobalRunning;
global b32 GlobalPause;
global b32 GlobalFullscreen;
global v2u GlobalEnforcedAspectRatio = {16, 9};
global b32 DEBUGGlobalShowCursor;
global u32 GlobalWindowPositionX;
global u32 GlobalWindowPositionY;
global Cursor GlobalHiddenCursor;

// NOTE(michiel): Explicit wrappers around dlsym, dlopen and dlclose
internal void *
LinuxLoadFunction(void *LibHandle, const char *Name)
{
    void *Symbol = dlsym(LibHandle, Name);
    if (!Symbol)
    {
        fprintf(stderr, "dlsym failed: %s\n", dlerror());
    }
    // TODO(michiel): Check if lib with underscore exists?!
    return Symbol;
}

internal void *
LinuxLoadLibrary(const char *LibName)
{
    void *Handle = NULL;
    
    Handle = dlopen(LibName, RTLD_NOW | RTLD_LOCAL);
    if (!Handle)
    {
        fprintf(stderr, "dlopen failed: %s\n", dlerror());
    }
    return Handle;
}

internal void
LinuxUnloadLibrary(void *Handle)
{
    if (Handle != NULL)
    {
        dlclose(Handle);
        Handle = NULL;
    }
}

// NOTE(michiel): Include other source files
#include "linux_sound.cpp"
#include "linux_joystick.cpp"

#include "handmade_renderer.h"
#include "handmade_renderer.cpp"
#include "linux_handmade_renderer.h"

//
// NOTE(michiel): File and process handling
//

internal void
LinuxGetEXEFileName(linux_state *State)
{
    // NOTE(casey): Never use MAX_PATH in code that is user-facing, because it
    // can be dangerous and lead to bad results.
    ssize_t NumRead = readlink("/proc/self/exe", State->EXEFileName, ArrayCount(State->EXEFileName) - 1);
    if (NumRead > 0)
    {
        State->OnePastLastEXEFileNameSlash = State->EXEFileName;
        for(char *Scan = State->EXEFileName;
            *Scan;
            ++Scan)
        {
            if(*Scan == '/')
            {
                State->OnePastLastEXEFileNameSlash = Scan + 1;
            }
        }
    }
}

internal void
LinuxBuildEXEPathFileName(linux_state *State, char *FileName, u32 Unique,
                          int DestCount, char *Dest)
{
    string A =
    {
        (umm)(State->OnePastLastEXEFileNameSlash - State->EXEFileName),
        (u8 *)State->EXEFileName,
    };
    string B = WrapZ(FileName);
    if (Unique == 0)
    {
        FormatString(DestCount, Dest, "%S%S", A, B);
    }
    else
    {
        FormatString(DestCount, Dest, "%S%d_%S", A, Unique, B);
    }
    //fprintf(stdout, "Build path %s\n", Dest);
}

internal void
LinuxBuildEXEPathFileName(linux_state *State, char *FileName,
                          int DestCount, char *Dest)
{
    LinuxBuildEXEPathFileName(State, FileName, 0, DestCount, Dest);
}

internal inline ino_t
LinuxFileId(char *FileName)
{
    struct stat Attr = {};
    if (stat(FileName, &Attr))
    {
        Attr.st_ino = 0;
    }
    
    return Attr.st_ino;
}

#if HANDMADE_INTERNAL
DEBUG_PLATFORM_EXECUTE_SYSTEM_COMMAND(DEBUGExecuteSystemCommand)
{
    debug_executing_process Result = {};
    
    char *RealCommand;
    if (StringsAreEqual(Command, "bash"))
    {
        RealCommand = CommandLine;
    }
    else
    {
        RealCommand = Command;
    }
    
    pid_t Pid = fork();
    
    if (Pid)
    {
        Assert(sizeof(Result.OSHandle) >= sizeof(pid_t));
        *(pid_t *)&Result.OSHandle = Pid;
    }
    else
    {
        // NOTE(michiel): This is the created child process
        chdir(Path);
        execl(RealCommand, CommandLine, (char *)0);
        exit(0);
    }
    
    return(Result);
}

DEBUG_PLATFORM_GET_PROCESS_STATE(DEBUGGetProcessState)
{
    debug_process_state Result = {};
    
    pid_t Pid = *(pid_t *)&Process.OSHandle;
    if (Pid > 0)
    {
        Result.StartedSuccessfully = true;
        
        int ProcessStatus = 0;
        if (waitpid(Pid, &ProcessStatus, WNOHANG) == Pid)
        {
            Result.ReturnCode = (s32)WEXITSTATUS(ProcessStatus);
        }
        else
        {
            Result.IsRunning = true;
        }
    }
    
    return(Result);
}
#endif

//
// NOTE(michiel): Dynamic code loading
//
internal PLATFORM_ERROR_MESSAGE(LinuxErrorMessage);

internal void
LinuxUnloadCode(linux_loaded_code *Loaded)
{
    if (Loaded->Library)
    {
        // TODO(casey): Currently, we never unload libraries, because
        // we may still be pointing to strings that are inside them
        // (despite our best efforts).  Should we just make "never unload"
        // be the policy?
        //LinuxUnloadLibrary(Loaded->Library);
        Loaded->Library = 0;
    }
    Loaded->LibraryFileID = 0;
    Loaded->IsValid = false;
    ZeroArray(Loaded->FunctionCount, Loaded->Functions);
}

internal void
LinuxLoadCode(linux_state *State, linux_loaded_code *Loaded)
{
    ino_t FileID = LinuxFileId(Loaded->LibraryFullPath);
    
    if (Loaded->LibraryFileID != FileID)
    {
        // NOTE(michiel): Create temp file, copy the library and load.
        // dlopen uses a caching mechanism based on the library name.
        // TODO(michiel): Do we still need this?
        char TempFileName[LINUX_STATE_FILE_NAME_COUNT];
        FormatString(LINUX_STATE_FILE_NAME_COUNT, TempFileName, "%sXXXXXX",
                     Loaded->LibraryFullPath);
        s32 FD = mkstemp(TempFileName);
        s32 OrigFile = open(Loaded->LibraryFullPath, O_RDONLY);
        
        if ((FD >=0) && (OrigFile >= 0))
        {
            char ReadBuffer[4096];
            ssize_t ReadCount = read(OrigFile, ReadBuffer, sizeof(ReadBuffer));
            
            while (ReadCount > 0)
            {
                char *WriteBuffer = ReadBuffer;
                ssize_t WriteCount;
                do {
                    WriteCount = write(FD, WriteBuffer, ReadCount);
                    
                    if (WriteCount >= 0)
                    {
                        ReadCount -= WriteCount;
                        WriteBuffer += WriteCount;
                    }
                    else if (errno != EINTR)
                    {
                        LinuxErrorMessage(PlatformError_Fatal, "Could not copy shared library while loading.");
                    }
                } while (ReadCount > 0);
                ReadCount = read(OrigFile, ReadBuffer, sizeof(ReadBuffer));
            }
            if (ReadCount == 0)
            {
                close(OrigFile);
                close(FD);
            }
            else
            {
                LinuxErrorMessage(PlatformError_Fatal, "Could not copy whole shared library while loading.");
            }
        }
        else
        {
            LinuxErrorMessage(PlatformError_Fatal, "Could not open shared library for copying.");
        }
        
        //LinuxUnloadLibrary(Loaded->Library);
        Loaded->LibraryFileID = FileID;
        Loaded->IsValid = false;
        
        Loaded->Library = LinuxLoadLibrary(TempFileName);
        if (Loaded->Library)
        {
            Loaded->IsValid = true;
            for (u32 FunctionIndex = 0;
                 FunctionIndex < Loaded->FunctionCount;
                 ++FunctionIndex)
            {
                void *Function = LinuxLoadFunction(Loaded->Library, Loaded->FunctionNames[FunctionIndex]);
                if (Function)
                {
                    Loaded->Functions[FunctionIndex] = Function;
                }
                else
                {
                    Loaded->IsValid = false;
                }
            }
        }
    }
    
    if(!Loaded->IsValid)
    {
        LinuxUnloadCode(Loaded);
    }
}

internal b32x
LinuxCheckForCodeChange(linux_loaded_code *Loaded)
{
    // Reload code if necessary
    ino_t LibraryId = LinuxFileId(Loaded->LibraryFullPath);
    b32x Result = (LibraryId != Loaded->LibraryFileID);
    return(Result);
}

internal void
LinuxReloadCode(linux_state *State, linux_loaded_code *Loaded)
{
    LinuxUnloadCode(Loaded);
    
    for(u32 LoadTryIndex = 0;
        !Loaded->IsValid && (LoadTryIndex < 100);
        ++LoadTryIndex)
    {
        LinuxLoadCode(State, Loaded);
        usleep(100000);
    }
}

//
// NOTE(michiel): X11 Window requests and drawing
//

internal void
LinuxProcessKeyboardMessage(game_button_state *NewState, b32 IsDown)
{
    if (NewState->EndedDown != IsDown)
    {
        NewState->EndedDown = IsDown;
        ++NewState->HalfTransitionCount;
    }
}

internal void
LinuxGetInputFileLocation(linux_state *State, b32 InputStream,
                          s32 SlotIndex, s32 DestCount, char *Dest)
{
    char Temp[64];
    snprintf(Temp, sizeof(Temp), "loop_edit_%d_%s.hmi", SlotIndex, InputStream ? "input" : "state");
    LinuxBuildEXEPathFileName(State, Temp, DestCount, Dest);
}

internal void
LinuxCreateHiddenCursor(Display *display, Window window)
{
    Pixmap Blank;
    XColor Dummy;
    char BlankBytes[1] = {0x00};
    Blank = XCreateBitmapFromData(display, window, BlankBytes, 1, 1);
    GlobalHiddenCursor = XCreatePixmapCursor(display, Blank, Blank, &Dummy, &Dummy, 0, 0);
    XFreePixmap(display, Blank);
}

internal void
LinuxHideCursor(Display *display, Window window)
{
    if (DEBUGGlobalShowCursor)
    {
        XDefineCursor(display, window, GlobalHiddenCursor);
        DEBUGGlobalShowCursor = false;
    }
}

internal void
LinuxShowCursor(Display *display, Window window)
{
    if (!DEBUGGlobalShowCursor)
    {
        XUndefineCursor(display, window);
        DEBUGGlobalShowCursor = true;
    }
}

internal v2u
LinuxGetWindowDimension(Display *display, Window window)
{
    XWindowAttributes WindowAttribs = {};
    XGetWindowAttributes(display, window, &WindowAttribs);
    
    v2u Result = {};
    Result.Width = (u32)WindowAttribs.width;
    Result.Height = (u32)WindowAttribs.height;
    return Result;
}

internal void
ToggleFullscreen(Display *display, Window window)
{
    GlobalFullscreen = !GlobalFullscreen;
    Atom FullscreenAtom = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
    Atom WindowState = XInternAtom(display, "_NET_WM_STATE", False);
    s32 Mask = SubstructureNotifyMask | SubstructureRedirectMask;
    // s32 Mask = StructureNotifyMask | ResizeRedirectMask;
    XEvent event = {};
    event.xclient.type = ClientMessage;
    event.xclient.serial = 0;
    event.xclient.send_event = True;
    // event.xclient.display = display;
    event.xclient.window = window;
    event.xclient.message_type = WindowState;
    event.xclient.format = 32;
    event.xclient.data.l[0] = (GlobalFullscreen ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE);  /* set (2 is toggle) */
    event.xclient.data.l[1] = (long)FullscreenAtom;
    event.xclient.data.l[2] = 0;
    
    XSendEvent(display, DefaultRootWindow(display), False, Mask, &event);
    // XFlush(display);
}

internal inline v2
LinuxGetMousePosition(Display *display, Window window)
{
    Window RetRoot, RetWin;
    s32 RootX, RootY;
    s32 WinX, WinY;
    u32 Mask;
    b32 QuerySuccess = XQueryPointer(display, window,
                                     &RetRoot, &RetWin,
                                     &RootX, &RootY, &WinX, &WinY, &Mask);
    
    v2 Result = {};
    if (QuerySuccess)
    {
        Result.x = (f32)WinX;
        Result.y = (f32)WinY;
    }
    return Result;
}

//
// NOTE(michiel): Memory
//

#if HANDMADE_INTERNAL
internal
DEBUG_PLATFORM_GET_MEMORY_STATS(LinuxGetMemoryStats)
{
    debug_platform_memory_stats Stats = {};
    
    BeginTicketMutex(&GlobalLinuxState.MemoryMutex);
    linux_memory_block *Sentinel = &GlobalLinuxState.MemorySentinel;
    for(linux_memory_block *SourceBlock = Sentinel->Next;
        SourceBlock != Sentinel;
        SourceBlock = SourceBlock->Next)
    {
        Assert(SourceBlock->Block.Size <= U32Max);
        
        ++Stats.BlockCount;
        Stats.TotalSize += SourceBlock->Block.Size;
        Stats.TotalUsed += SourceBlock->Block.Used;
    }
    EndTicketMutex(&GlobalLinuxState.MemoryMutex);
    
    return(Stats);
}
#endif

internal void
LinuxVerifyMemoryListIntegrity(void)
{
    BeginTicketMutex(&GlobalLinuxState.MemoryMutex);
    local_persist u32 FailCounter;
    linux_memory_block *Sentinel = &GlobalLinuxState.MemorySentinel;
    for(linux_memory_block *SourceBlock = Sentinel->Next;
        SourceBlock != Sentinel;
        SourceBlock = SourceBlock->Next)
    {
        Assert(SourceBlock->Block.Size <= U32Max);
    }
    ++FailCounter;
    EndTicketMutex(&GlobalLinuxState.MemoryMutex);
}

internal void
LinuxFreeMemoryBlock(linux_memory_block *Block)
{
    u32 Size = Block->Block.Size;
    u64 Flags = Block->Block.Flags;
    umm PageSize = sysconf(_SC_PAGESIZE);
    umm TotalSize = Size + sizeof(linux_memory_block);
    if(Flags & PlatformMemory_UnderflowCheck)
    {
        TotalSize = Size + 2*PageSize;
    }
    else if(Flags & PlatformMemory_OverflowCheck)
    {
        umm SizeRoundedUp = AlignPow2(Size, PageSize);
        TotalSize = SizeRoundedUp + 2*PageSize;
    }
    
    BeginTicketMutex(&GlobalLinuxState.MemoryMutex);
    Block->Prev->Next = Block->Next;
    Block->Next->Prev = Block->Prev;
    EndTicketMutex(&GlobalLinuxState.MemoryMutex);
    
    munmap(Block, TotalSize);
}

internal void
LinuxClearBlocksByMask(linux_state *State, u64 Mask)
{
    for(linux_memory_block *BlockIter = State->MemorySentinel.Next;
        BlockIter != &State->MemorySentinel;
        )
    {
        linux_memory_block *Block = BlockIter;
        BlockIter = BlockIter->Next;
        
        if((Block->LoopingFlags & Mask) == Mask)
        {
            LinuxFreeMemoryBlock(Block);
        }
        else
        {
            Block->LoopingFlags = 0;
        }
    }
}

inline b32x
LinuxIsInLoop(linux_state *State)
{
    b32x Result = ((State->InputRecordingIndex != 0) ||
                   (State->InputPlayingIndex));
    return(Result);
}

PLATFORM_ALLOCATE_MEMORY(LinuxAllocateMemory)
{
    // NOTE(casey): We require memory block headers not to change the cache
    // line alignment of an allocation
    Assert(sizeof(linux_memory_block) == 64);
    
    umm PageSize = sysconf(_SC_PAGESIZE);
    umm TotalSize = Size + sizeof(linux_memory_block);
    umm BaseOffset = sizeof(linux_memory_block);
    umm ProtectOffset = 0;
    if(Flags & PlatformMemory_UnderflowCheck)
    {
        TotalSize = Size + 2*PageSize;
        BaseOffset = 2*PageSize;
        ProtectOffset = PageSize;
    }
    else if(Flags & PlatformMemory_OverflowCheck)
    {
        umm SizeRoundedUp = AlignPow2(Size, PageSize);
        TotalSize = SizeRoundedUp + 2*PageSize;
        BaseOffset = PageSize + SizeRoundedUp - Size;
        ProtectOffset = PageSize + SizeRoundedUp;
    }
    
    linux_memory_block *Block = (linux_memory_block *)
        mmap(0, TotalSize, PROT_READ|PROT_WRITE,
             MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    Assert(Block);
    Block->Block.Base = (u8 *)Block + BaseOffset;
    Assert(Block->Block.Used == 0);
    Assert(Block->Block.ArenaPrev == 0);
    
    if(Flags & (PlatformMemory_UnderflowCheck|PlatformMemory_OverflowCheck))
    {
        s32 Error = mprotect((u8 *)Block + ProtectOffset, PageSize, PROT_NONE);
        Assert(Error == 0);
    }
    
    linux_memory_block *Sentinel = &GlobalLinuxState.MemorySentinel;
    Block->Next = Sentinel;
    Block->Block.Size = Size;
    Block->Block.Flags = Flags;
    Block->LoopingFlags = 0;
    if (LinuxIsInLoop(&GlobalLinuxState) && !(Flags & PlatformMemory_NotRestored))
    {
        Block->LoopingFlags = LinuxMem_AllocatedDuringLooping;
    }
    
    BeginTicketMutex(&GlobalLinuxState.MemoryMutex);
    Block->Prev = Sentinel->Prev;
    Block->Prev->Next = Block;
    Block->Next->Prev = Block;
    EndTicketMutex(&GlobalLinuxState.MemoryMutex);
    
    platform_memory_block *PlatBlock = &Block->Block;
    return(PlatBlock);
}

PLATFORM_DEALLOCATE_MEMORY(LinuxDeallocateMemory)
{
    if(Block)
    {
        linux_memory_block *LinuxBlock = ((linux_memory_block *)Block);
        if(LinuxIsInLoop(&GlobalLinuxState) && !(LinuxBlock->Block.Flags & PlatformMemory_NotRestored))
        {
            LinuxBlock->LoopingFlags = LinuxMem_FreedDuringLooping;
        }
        else
        {
            LinuxFreeMemoryBlock(LinuxBlock);
        }
    }
}

//
// Replays
//

internal void
LinuxBeginRecordingInput(linux_state *State, int InputRecordingIndex)
{
    // TODO(michiel): mmap to file?
    char FileName[LINUX_STATE_FILE_NAME_COUNT];
    LinuxGetInputFileLocation(State, true, InputRecordingIndex, sizeof(FileName), FileName);
    State->RecordingHandle = open(FileName, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if(State->RecordingHandle >= 0)
    {
        //ssize_t BytesWritten = write(FileHandle, Memory, MemorySize);
        ssize_t BytesWritten;
        
        State->InputRecordingIndex = InputRecordingIndex;
        linux_memory_block *Sentinel = &GlobalLinuxState.MemorySentinel;
        
        BeginTicketMutex(&GlobalLinuxState.MemoryMutex);
        for(linux_memory_block *SourceBlock = Sentinel->Next;
            SourceBlock != Sentinel;
            SourceBlock = SourceBlock->Next)
        {
            if(!(SourceBlock->Block.Flags & PlatformMemory_NotRestored))
            {
                linux_saved_memory_block DestBlock;
                void *BasePointer = SourceBlock->Block.Base;
                DestBlock.BasePointer = (u64)BasePointer;
                DestBlock.Size = SourceBlock->Block.Size;
                BytesWritten = write(State->RecordingHandle, &DestBlock, sizeof(DestBlock));
                Assert(DestBlock.Size <= U32Max);
                BytesWritten = write(State->RecordingHandle, BasePointer, (u32)DestBlock.Size);
            }
        }
        EndTicketMutex(&GlobalLinuxState.MemoryMutex);
        
        linux_saved_memory_block DestBlock = {};
        BytesWritten = write(State->RecordingHandle, &DestBlock, sizeof(DestBlock));
    }
}

internal void
LinuxEndRecordingInput(linux_state *State)
{
    syncfs(State->RecordingHandle);
    close(State->RecordingHandle);
    State->InputRecordingIndex = 0;
}

internal void
LinuxBeginInputPlayBack(linux_state *State, int InputPlayingIndex)
{
    LinuxClearBlocksByMask(State, LinuxMem_AllocatedDuringLooping);
    
    char FileName[LINUX_STATE_FILE_NAME_COUNT];
    LinuxGetInputFileLocation(State, true, InputPlayingIndex, sizeof(FileName), FileName);
    State->PlaybackHandle = open(FileName, O_RDONLY);
    if(State->PlaybackHandle >= 0)
    {
        State->InputPlayingIndex = InputPlayingIndex;
        
        for(;;)
        {
            linux_saved_memory_block Block = {};
            ssize_t BytesRead = read(State->PlaybackHandle, &Block, sizeof(Block));
            if(Block.BasePointer != 0)
            {
                void *BasePointer = (void *)Block.BasePointer;
                Assert(Block.Size <= U32Max);
                BytesRead = read(State->PlaybackHandle, BasePointer, (u32)Block.Size);
            }
            else
            {
                break;
            }
        }
        // TODO(casey): Stream memory in from the file!
    }
}

internal void
LinuxEndInputPlayBack(linux_state *State)
{
    LinuxClearBlocksByMask(State, LinuxMem_FreedDuringLooping);
    close(State->PlaybackHandle);
    State->InputPlayingIndex = 0;
}

internal void
LinuxRecordInput(linux_state *State, game_input *NewInput)
{
    ssize_t BytesWritten = write(State->RecordingHandle, NewInput, sizeof(*NewInput));
    Assert(BytesWritten == sizeof(*NewInput));
}

internal void
LinuxPlayBackInput(linux_state *State, game_input *NewInput)
{
    ssize_t BytesRead = read(State->PlaybackHandle, NewInput, sizeof(*NewInput));
    if(BytesRead == 0)
    {
        // NOTE(casey): We've hit the end of the stream, go back to the beginning
        s32 PlayingIndex = State->InputPlayingIndex;
        LinuxEndInputPlayBack(State);
        LinuxBeginInputPlayBack(State, PlayingIndex);
        read(State->PlaybackHandle, NewInput, sizeof(*NewInput));
    }
    else
    {
        Assert(BytesRead == sizeof(*NewInput));
    }
}


//
// NOTE(michiel): Timing
//

internal inline struct timespec
LinuxGetWallClock()
{
    struct timespec Clock;
    clock_gettime(CLOCK_MONOTONIC, &Clock);
    return Clock;
}

internal inline f32
LinuxGetSecondsElapsed(struct timespec Start, struct timespec End)
{
    return ((f32)(End.tv_sec - Start.tv_sec)
            + ((f32)(End.tv_nsec - Start.tv_nsec) * 1e-9f));
}

//
// NOTE(michiel): Threading
//

internal void LinuxAddEntry(platform_work_queue *Queue, platform_work_queue_callback *Callback, void *Data)
{
    u32 NewNextEntryToWrite = (Queue->NextEntryToWrite + 1) % ArrayCount(Queue->Entries);
    Assert(NewNextEntryToWrite != Queue->NextEntryToRead);
    platform_work_queue_entry *Entry = Queue->Entries + Queue->NextEntryToWrite;
    Entry->Callback = Callback;
    Entry->Data = Data;
    ++Queue->CompletionGoal;
    
    asm volatile("" ::: "memory");
    
    Queue->NextEntryToWrite = NewNextEntryToWrite;
    sem_post(&Queue->SemaphoreHandle);
}

internal b32
LinuxDoNextWorkQueueEntry(platform_work_queue *Queue)
{
    bool32 WeShouldSleep = false;
    
    uint32 OriginalNextEntryToRead = Queue->NextEntryToRead;
    uint32 NewNextEntryToRead = (OriginalNextEntryToRead + 1) % ArrayCount(Queue->Entries);
    if(OriginalNextEntryToRead != Queue->NextEntryToWrite)
    {
        uint32 Index = __sync_val_compare_and_swap(&Queue->NextEntryToRead,
                                                   OriginalNextEntryToRead,
                                                   NewNextEntryToRead);
        if(Index == OriginalNextEntryToRead)
        {
            platform_work_queue_entry Entry = Queue->Entries[Index];
            // TODO(casey): If we were serious about threading, there would be a thread-specific
            // struct that contained the scratch arena for the thread that it can use
            // for all its temporary work.
            Entry.Callback(Queue, Entry.Data);
            __sync_fetch_and_add(&Queue->CompletionCount, 1);
        }
    }
    else
    {
        WeShouldSleep = true;
    }
    
    return(WeShouldSleep);
}

internal void
LinuxCompleteAllWork(platform_work_queue *Queue)
{
    while(Queue->CompletionGoal != Queue->CompletionCount)
    {
        LinuxDoNextWorkQueueEntry(Queue);
    }
    
    Queue->CompletionGoal = 0;
    Queue->CompletionCount = 0;
}

void *
ThreadProc(void *Parameter)
{
    linux_thread_startup *Thread = (linux_thread_startup *)Parameter;
    platform_work_queue *Queue = Thread->Queue;
    
    for(;;)
    {
        if(LinuxDoNextWorkQueueEntry(Queue))
        {
            sem_wait(&Queue->SemaphoreHandle);
        }
    }
    
    //    return(0);
}

internal void
LinuxMakeQueue(platform_work_queue *Queue, u32 ThreadCount, linux_thread_startup *Startups)
{
    Queue->CompletionGoal = 0;
    Queue->CompletionCount = 0;
    
    Queue->NextEntryToWrite = 0;
    Queue->NextEntryToRead = 0;
    
    uint32 InitialCount = 0;
    sem_init(&Queue->SemaphoreHandle, 0, InitialCount);
    
    for(uint32 ThreadIndex = 0;
        ThreadIndex < ThreadCount;
        ++ThreadIndex)
    {
        linux_thread_startup *Startup = Startups + ThreadIndex;
        Startup->Queue = Queue;
        
        pthread_attr_t Attr;
        pthread_t ThreadID;
        pthread_attr_init(&Attr);
        // TODO(michiel): Check return values
        pthread_attr_setdetachstate(&Attr, PTHREAD_CREATE_DETACHED);
        if (pthread_attr_setstacksize(&Attr, 0x100000))
        {
            fprintf(stderr, "Failed to set the thread stack size to 1MB\n");
        }
        int result = pthread_create(&ThreadID, &Attr, ThreadProc, Startup);
        pthread_attr_destroy(&Attr);
    }
}

//
// NOTE(michiel): Keyboard mapping
//

#if 0
// NOTE(michiel): Reference
global unsigned int GlobalX11Map[] = {
    XK_Home, XK_End, XK_KP_Divide, XK_KP_Multiply, XK_KP_Add, XK_KP_Subtract, XK_BackSpace, XK_Tab,
    XK_Return, XK_Linefeed, XK_Page_Up, XK_Page_Down,
    XK_KP_0, XK_KP_1, XK_KP_2, XK_KP_3, XK_KP_4, XK_KP_5, XK_KP_6, XK_KP_7, XK_KP_8, XK_KP_9,
    XK_Insert, XK_Escape, XK_KP_Decimal, XK_KP_Enter, XK_space, XK_quotedbl, XK_comma, XK_minus, XK_period, XK_slash,
    XK_0, XK_1, XK_2, XK_3, XK_4, XK_5, XK_6, XK_7, XK_8, XK_9,
    XK_semicolon, XK_equal,
    XK_A, XK_B, XK_C, XK_D, XK_E, XK_F, XK_G, XK_H, XK_I, XK_J, XK_K, XK_L, XK_M,
    XK_N, XK_O, XK_P, XK_Q, XK_R, XK_S, XK_T, XK_U, XK_V, XK_W, XK_X, XK_Y, XK_Z,
    XK_bracketleft, XK_backslash, XK_bracketright, XK_grave,
    XK_Control_L, XK_Control_R, XK_Alt_L, XK_Alt_R, XK_Shift_L, XK_Shift_R, XK_Super_L, XK_Super_R,
    XK_F1, XK_F2, XK_F3, XK_F4, XK_F5, XK_F6, XK_F7, XK_F8, XK_F9, XK_F10, XK_F11, XK_F12,
    XK_Num_Lock, XK_Scroll_Lock, XK_Print, XK_Break,
    XK_Up, XK_Down, XK_Left, XK_Right, XK_Delete,
};
#endif

internal void
LinuxProcessPendingMessages(linux_state *State, Display *display, Window window,
                            Atom WmDeleteWindow, game_controller_input *KeyboardController,
                            game_input *Input, v2 *MouseP, v2u *Dimension)
{
    while (GlobalRunning && XPending(display))
    {
        XEvent Event;
        XNextEvent(display, &Event);
        
        // NOTE(michiel): Don't skip the scroll key Events
        if (Event.type == ButtonRelease)
        {
            if ((Event.xbutton.button != 4) &&
                (Event.xbutton.button != 5) &&
                XEventsQueued(display, QueuedAfterReading))
            {
                // NOTE(michiel): Skip the auto repeat key
                XEvent NextEvent;
                XPeekEvent(display, &NextEvent);
                if ((NextEvent.type == ButtonPress) &&
                    (NextEvent.xbutton.time == Event.xbutton.time) &&
                    (NextEvent.xbutton.button == Event.xbutton.button))
                {
                    XNextEvent(display, &Event);
                    continue;
                }
            }
        }
        // NOTE(michiel): Skip the Keyboard
        if (Event.type == KeyRelease && XEventsQueued(display, QueuedAfterReading))
        {
            XEvent NextEvent;
            XPeekEvent(display, &NextEvent);
            if ((NextEvent.type == KeyPress) &&
                (NextEvent.xkey.time == Event.xkey.time) &&
                (NextEvent.xkey.keycode == Event.xkey.keycode))
            {
                XNextEvent(display, &Event);
                continue;
            }
        }
        
        switch (Event.type)
        {
            case ConfigureNotify:
            {
                s32 W = Event.xconfigure.width;
                s32 H = Event.xconfigure.height;
                if((Dimension->Width != W) || (Dimension->Height != H))
                {
                    Dimension->Width = (u32)W;
                    Dimension->Height = (u32)H;
                }
            } break;
            
            case DestroyNotify:
            {
                if ((display == Event.xdestroywindow.display) &&
                    (window == Event.xdestroywindow.window))
                {
                    GlobalRunning = false;
                }
            } break;
            
            case ClientMessage:
            {
                if ((Atom)Event.xclient.data.l[0] == WmDeleteWindow)
                {
                    GlobalRunning = false;
                }
            } break;
            
            case MotionNotify:
            {
                MouseP->x = (f32)Event.xmotion.x;
                MouseP->y = (f32)Event.xmotion.y;
            } break;
            
            case ButtonRelease:
            case ButtonPress:
            {
                if (Event.xbutton.button == LINUX_LEFT_MOUSE)
                {
                    LinuxProcessKeyboardMessage(&Input->MouseButtons[PlatformMouseButton_Left],
                                                Event.type == ButtonPress);
                }
                else if (Event.xbutton.button == LINUX_MIDDLE_MOUSE)
                {
                    LinuxProcessKeyboardMessage(&Input->MouseButtons[PlatformMouseButton_Middle],
                                                Event.type == ButtonPress);
                }
                else if (Event.xbutton.button == LINUX_RIGHT_MOUSE)
                {
                    LinuxProcessKeyboardMessage(&Input->MouseButtons[PlatformMouseButton_Right],
                                                Event.type == ButtonPress);
                }
                else if (Event.xbutton.button == 4)
                {
                    ++(Input->ClipSpaceMouseP.z);
                }
                else if (Event.xbutton.button == 5)
                {
                    --(Input->ClipSpaceMouseP.z);
                }
                else if (Event.xbutton.button == LINUX_EXT1_MOUSE)
                {
                    LinuxProcessKeyboardMessage(&Input->MouseButtons[PlatformMouseButton_Extended0],
                                                Event.type == ButtonPress);
                }
                else if (Event.xbutton.button == LINUX_EXT2_MOUSE)
                {
                    LinuxProcessKeyboardMessage(&Input->MouseButtons[PlatformMouseButton_Extended1],
                                                Event.type == ButtonPress);
                    // } else {
                    //     printf("Uncaught button: %u\n", Event.xbutton.button);
                }
            } break;
            
            case KeyRelease:
            case KeyPress:
            {
                b32 AltKeyWasDown = Event.xkey.state & KEYCODE_ALT_MASK;
                b32 ShiftKeyWasDown = Event.xkey.state & KEYCODE_SHIFT_MASK;
                
                if (!GlobalPause)
                {
                    if (Event.xkey.keycode == KEYCODE_W)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->MoveUp, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_A)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->MoveLeft, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_S)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->MoveDown, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_D)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->MoveRight, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_Q)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->LeftShoulder, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_E)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->RightShoulder, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_UP)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->ActionUp, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_DOWN)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->ActionDown, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_LEFT)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->ActionLeft, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_RIGHT)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->ActionRight, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_ESCAPE)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->Back, Event.type == KeyPress);
                    }
                    else if (Event.xkey.keycode == KEYCODE_SPACE)
                    {
                        LinuxProcessKeyboardMessage(&KeyboardController->Start, Event.type == KeyPress);
                    }
                }
                
                if ((Event.xkey.keycode == KEYCODE_SHIFT_L) || (Event.xkey.keycode == KEYCODE_SHIFT_R))
                {
                    Input->ShiftDown = (Event.type == KeyPress);
                }
                else if ((Event.xkey.keycode == KEYCODE_ALT_L) || (Event.xkey.keycode == KEYCODE_ALT_R))
                {
                    Input->AltDown = (Event.type == KeyPress);
                }
                else if ((Event.xkey.keycode == KEYCODE_CTRL_L) || (Event.xkey.keycode == KEYCODE_CTRL_R))
                {
                    Input->ControlDown = (Event.type == KeyPress);
                }
                
#if HANDMADE_INTERNAL
                else if (Event.xkey.keycode == KEYCODE_P)
                {
                    if (Event.type == KeyPress)
                    {
                        GlobalPause = !GlobalPause;
                    }
                }
                else if (Event.xkey.keycode == KEYCODE_L)
                {
                    if (Event.type == KeyPress)
                    {
                        if (AltKeyWasDown)
                        {
                            LinuxBeginInputPlayBack(State, 1);
                        }
                        else
                        {
                            if(State->InputPlayingIndex == 0)
                            {
                                if(State->InputRecordingIndex == 0)
                                {
                                    LinuxBeginRecordingInput(State, 1);
                                }
                                else
                                {
                                    LinuxEndRecordingInput(State);
                                    LinuxBeginInputPlayBack(State, 1);
                                }
                            }
                            else
                            {
                                LinuxEndInputPlayBack(State);
                            }
                        }
                    }
                }
#endif
                if (Event.type == KeyPress)
                {
                    if ((Event.xkey.keycode == (KEYCODE_F1 + 3)) && AltKeyWasDown)
                    {
                        GlobalRunning = false;
                    }
                    else if ((Event.xkey.keycode == KEYCODE_ENTER) && AltKeyWasDown)
                    {
                        ToggleFullscreen(display, window);
                    }
                    else if ((Event.xkey.keycode >= KEYCODE_F1) && (Event.xkey.keycode <= KEYCODE_F10))
                    {
                        Input->FKeyPressed[Event.xkey.keycode - KEYCODE_F1 + 1] = true;
                    }
                    else if ((Event.xkey.keycode >= KEYCODE_F11) && (Event.xkey.keycode <= KEYCODE_F12))
                    {
                        // NOTE(michiel): Because of X11 mapping we get to do the function keys in 2 steps :)
                        Input->FKeyPressed[Event.xkey.keycode - KEYCODE_F11 + 1] = true;
                    }
                }
            } break;
            
            default:
            break;
        }
    }
}

//
// NOTE(michiel): Platform file handling
//

struct linux_find_file
{
    DIR *Dir;
    struct dirent *FileData;
};

struct linux_platform_file_group
{
    memory_arena Memory;
};

enum pattern_match_flag
{
    PatternMatchFlag_None      = 0x00,
    PatternMatchFlag_MaySkip   = 0x01,
    PatternMatchFlag_Restarted = 0x02,
};

internal b32
MatchPattern(char *Pattern, char *String)
{
    b32 Result = false;
    u32 Flags = PatternMatchFlag_None;
    char *P = Pattern;
    char *S = String;
    while (*S)
    {
        if (*P == '*')
        {
            Flags = PatternMatchFlag_MaySkip;
            ++P;
        }
        else if (Flags == PatternMatchFlag_MaySkip)
        {
            Result = true;
            if (*S == *P)
            {
                Flags = PatternMatchFlag_None;
                ++P;
                ++S;
            }
            else
            {
                Flags = PatternMatchFlag_MaySkip;
                ++S;
            }
        }
        else if (*S != *P)
        {
            if (Flags == PatternMatchFlag_Restarted)
            {
                break;
            }
            Result = false;
            Flags = PatternMatchFlag_Restarted;
            P = Pattern;
        }
        else
        {
            Result = true;
            Flags = PatternMatchFlag_None;
            ++P;
            ++S;
        }
    }
    return Result && (*P == 0);
}

internal platform_file_info *
LinuxAllocateFileInfo(platform_file_group *FileGroup, struct stat *Data)
{
    linux_platform_file_group *LinuxFileGroup = (linux_platform_file_group *)FileGroup->Platform;
    
    platform_file_info *Info = PushStruct(&LinuxFileGroup->Memory, platform_file_info);
    Info->Next = FileGroup->FirstFileInfo;
    Info->FileDate = (u64)Data->st_mtime;
    Info->FileSize = (u64)Data->st_size;
    FileGroup->FirstFileInfo = Info;
    ++FileGroup->FileCount;
    
    return Info;
}

internal PLATFORM_GET_ALL_FILE_OF_TYPE_BEGIN(LinuxGetAllFilesOfTypeBegin)
{
    platform_file_group Result = {};
    
    linux_platform_file_group *LinuxFileGroup = BootstrapPushStruct(linux_platform_file_group, Memory);
    Result.Platform = LinuxFileGroup;
    
    char *Stem = "";
    char *Wildcard = "*.*";
    
    switch(Type)
    {
        case PlatformFileType_AssetFile:
        {
            Stem = "data";
            Wildcard = "*.hha";
        } break;
        
        case PlatformFileType_SavedGameFile:
        {
            Stem = "data";
            Wildcard = "*.hhs";
        } break;
        
        case PlatformFileType_HHT:
        {
            Stem = "tags";
            Wildcard = "*.hht";
        } break;
        
        
        case PlatformFileType_Dump:
        {
            Stem = "debug";
            Wildcard = "*.dump";
        } break;
        
        InvalidDefaultCase;
    }
    
    u32 StemSize = 0;
    for (char *Scan = Stem; *Scan; ++Scan)
    {
        ++StemSize;
    }
    
    DIR *TopDir = opendir(".");
    
    if (TopDir)
    {
        struct dirent *StemData = readdir(TopDir);
        while (StemData)
        {
            if (StringsAreEqual(Stem, StemData->d_name))
            {
                DIR *StemDir = opendir(Stem);
                struct dirent *FileData = readdir(StemDir);
                while (FileData)
                {
                    if (MatchPattern(Wildcard, FileData->d_name))
                    {
                        char *FileName = FileData->d_name;
                        char PathName[256];
                        
                        FormatString(sizeof(PathName), PathName, "%s/%s", Stem, FileName);
                        
                        struct stat FindData = {};
                        u32 statError = stat(PathName, &FindData);
                        if (statError == 0)
                        {
                            platform_file_info *Info = LinuxAllocateFileInfo(&Result, &FindData);
                            char *BaseNameBegin = PathName;
                            char *BaseNameEnd = 0;
                            
                            char *Scan = BaseNameBegin;
                            while (*Scan)
                            {
                                if (*Scan == '/')
                                {
                                    BaseNameBegin = Scan + 1;
                                }
                                if (*Scan == '.')
                                {
                                    BaseNameEnd = Scan;
                                }
                                ++Scan;
                            }
                            if (!BaseNameEnd)
                            {
                                BaseNameEnd = Scan;
                            }
                            
                            u32 BaseNameSize = (u32)(BaseNameEnd - BaseNameBegin);
                            Info->BaseName = PushAndNullTerminate(&LinuxFileGroup->Memory, BaseNameSize, BaseNameBegin);
                            
                            u32 FileNameSize = (u32)(Scan - PathName);
                            Info->Platform = PushAndNullTerminate(&LinuxFileGroup->Memory, FileNameSize, PathName);
                        }
                    }
                    FileData = readdir(StemDir);
                }
                closedir(StemDir);
            }
            StemData = readdir(TopDir);
        }
        closedir(TopDir);
    }
    
    return(Result);
}

internal PLATFORM_GET_ALL_FILE_OF_TYPE_END(LinuxGetAllFilesOfTypeEnd)
{
    linux_platform_file_group *LinuxFileGroup = (linux_platform_file_group *)FileGroup->Platform;
    if(LinuxFileGroup)
    {
        Clear(&LinuxFileGroup->Memory);
    }
}

internal PLATFORM_GET_FILE_BY_PATH(LinuxGetFileByPath)
{
    linux_platform_file_group *LinuxFileGroup = (linux_platform_file_group *)FileGroup->Platform;
    platform_file_info *Result = 0;
    
    struct stat Data = {};
    u32 statError = stat(Path, &Data);
    if ((statError == 0) ||
        (ModeFlags & OpenFile_Write))
    {
        Result = LinuxAllocateFileInfo(FileGroup, &Data);
        u32 PathSize = StringLength(Path);
        // TODO(casey): Should the base name be duplicated??
        Result->BaseName = PushAndNullTerminate(&LinuxFileGroup->Memory, PathSize, Path);
        Result->Platform = PushAndNullTerminate(&LinuxFileGroup->Memory, PathSize, Path);
    }
    
    return(Result);
}

internal PLATFORM_FILE_ERROR(LinuxFileError)
{
#if HANDMADE_INTERNAL
    fprintf(stderr, "LINUX FILE ERROR: %s\n", Message);
#endif
    
    Handle->NoErrors = false;
}

internal PLATFORM_OPEN_FILE(LinuxOpenFile)
{
    platform_file_handle Result = {};
    Assert(sizeof(s32) <= sizeof(Result.Platform));
    
    s32 HandlePermissions = 0;
    if ((ModeFlags & OpenFile_Read) &&
        (ModeFlags & OpenFile_Write))
    {
        HandlePermissions = O_RDWR | O_CREAT;
    }
    else if (ModeFlags & OpenFile_Read)
    {
        HandlePermissions = O_RDONLY;
    }
    else if (ModeFlags & OpenFile_Write)
    {
        HandlePermissions = O_WRONLY | O_CREAT | O_TRUNC;
    }
    
    char *FileName = (char *)Info->Platform;
    s32 FileHandle = open(FileName, HandlePermissions, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    Result.NoErrors = (FileHandle >= 0);
    *(s32 *)&Result.Platform = FileHandle;
    
    return(Result);
}

internal PLATFORM_SET_FILE_SIZE(LinuxSetFileSize)
{
    if (PlatformNoFileErrors(Handle))
    {
        s32 LinuxHandle = *(s32 *)&Handle->Platform;
        
        if (ftruncate(LinuxHandle, Size))
        {
            LinuxFileError(Handle, "Unable to set the end of the file.");
        }
    }
}

internal PLATFORM_READ_DATA_FROM_FILE(LinuxReadDataFromFile)
{
    if(PlatformNoFileErrors(Handle))
    {
        s32 LinuxHandle = *(s32 *)&Handle->Platform;
        
        s64 BytesRead = pread(LinuxHandle, Dest, Size, (s64)Offset);
        if ((s64)Size == BytesRead)
        {
            // NOTE(michiel): File read succeeded!
        }
        else
        {
            LinuxFileError(Handle, "Read file failed.");
        }
    }
}

internal PLATFORM_WRITE_DATA_TO_FILE(LinuxWriteDataToFile)
{
    if(PlatformNoFileErrors(Handle))
    {
        s32 LinuxHandle = *(s32 *)&Handle->Platform;
        
        s64 BytesWritten = pwrite(LinuxHandle, Source, Size, (s64)Offset);
        if ((s64)Size == BytesWritten)
        {
            // NOTE(michiel): File write succeeded!
        }
        else
        {
            LinuxFileError(Handle, "Write file failed.");
        }
    }
}

internal PLATFORM_ATOMIC_REPLACE_FILE_CONTENTS(LinuxAtomicReplaceFileContents)
{
    b32 Result = false;
    
    char *ExistingFileName = (char *)Info->Platform;
    char *LastSlash = ExistingFileName;
    for(char *Scan = ExistingFileName;
        *Scan;
        ++Scan)
    {
        if((*Scan == '/') ||
           (*Scan == '\\'))
        {
            LastSlash = Scan;
        }
    }
    
    string Path = {
        SafeTruncateToU32(LastSlash - ExistingFileName),
        (u8 *)ExistingFileName
    };
    char TempFileName[512];
    FormatString(sizeof(TempFileName), TempFileName, "%S/hh_XXXXXX", Path);
    s32 File = mkstemp(TempFileName);
    
    if(File >= 0)
    {
        b32x WriteOK = false;
        s64 BytesWritten = write(File, Source, SafeTruncateToU32(Size));
        WriteOK = (BytesWritten == Size);
        close(File);
        
        if(WriteOK)
        {
            
            Result = !rename(TempFileName, ExistingFileName);
        }
    }
    
    if(!Result)
    {
        remove(TempFileName);
    }
    
    return(Result);
}

internal PLATFORM_CLOSE_FILE(LinuxCloseFile)
{
    s32 LinuxHandle = *(s32 *)&Handle->Platform;
    if (LinuxHandle >= 0)
    {
        close(LinuxHandle);
    }
}

internal PLATFORM_ERROR_MESSAGE(LinuxErrorMessage)
{
    // NOTE(michiel): Shameless copy of http://goliath32.com/sw/MessageBoxX11.c
    char *Caption = "Handmade Hero Warning";
    
    if (Type == PlatformError_Fatal)
    {
        Caption = "Handmade Hero Fatal Error";
    }
    
    Display *display = GlobalLinuxState.DefaultDisplay; // XOpenDisplay(0);
    if (display)
    {
        s32 Black = BlackPixel(display, DefaultScreen(display));
        s32 White = WhitePixel(display, DefaultScreen(display));
        
        Window window = XCreateSimpleWindow(display, DefaultRootWindow(display),
                                            0, 0, 100, 100, 0, White, Black);
        XSelectInput(display, window, ExposureMask | StructureNotifyMask |
                     KeyReleaseMask | PointerMotionMask | ButtonPressMask |
                     ButtonReleaseMask);
        XMapWindow(display, window);
        XStoreName(display, window, Caption);
        
        Atom WmDelete = XInternAtom(display, "WM_DELETE_WINDOW", True);
        XSetWMProtocols(display, window, &WmDelete, 1);
        
        GC GraphicsContext = XCreateGC(display, window, 0, 0);
        XSetForeground(display, GraphicsContext, White);
        XSetBackground(display, GraphicsContext, Black);
        
        XFontStruct *Font = XQueryFont(display, XGContextFromGC(GraphicsContext));
        if (Font)
        {
            s32 Width = 0;
            s32 LineHeight = 0;
            char *StartOfLine = Message;
            s32 Lines = 0;
            while (*StartOfLine)
            {
                char *EndOfLine = StartOfLine;
                while (*EndOfLine && !IsEndOfLine(*EndOfLine)) {
                    ++EndOfLine;
                }
                
                s32 Direction, Ascent, Descent;
                XCharStruct CharOverall;
                XTextExtents(Font, StartOfLine, (u32)(EndOfLine - StartOfLine), &Direction, &Ascent, &Descent,
                             &CharOverall);
                
                Width = Maximum(Width, CharOverall.width);
                LineHeight = Maximum(LineHeight, Ascent + Descent);
                
                if (IsEndOfLine(*EndOfLine)) {
                    ++EndOfLine;
                }
                StartOfLine = EndOfLine;
                ++Lines;
            }
            
            Width += 20;
            s32 Height = Lines * LineHeight + LineHeight + 40;
            s32 X = (DisplayWidth(display, DefaultScreen(display)) - Width) / 2;
            s32 Y = (DisplayHeight(display, DefaultScreen(display)) - Height) / 2;
            
            XMoveResizeWindow(display, window, X, Y, Width, Height);
            
            s32 Direction, Ascent, Descent;
            XCharStruct CharOverall;
            XTextExtents(Font, "OK", 2, &Direction, &Ascent, &Descent, &CharOverall);
            
            s32 ButtonWidth = CharOverall.width + 30;
            s32 ButtonHeight = Ascent + Descent + 5;
            s32 ButtonX = (Width - ButtonWidth) / 2;
            s32 ButtonY = Height - LineHeight - 15;
            s32 ButtonTextX = ButtonX + 15;
            s32 ButtonTextY = ButtonY + ButtonHeight - 3;
            b32 ButtonActive = false;
            b32 ButtonClicked = false;
            char *ButtonText = "OK";
            
            XFreeFontInfo(0, Font, 1);
            
            XUnmapWindow(display, window);
            
            XSizeHints Hints = {};
            Hints.flags = PSize | PMinSize | PMaxSize;
            Hints.min_width = Hints.max_width = Hints.base_width = Width;
            Hints.min_height = Hints.max_height = Hints.base_height = Height;
            
            XSetWMNormalHints(display, window, &Hints);
            XMapRaised(display, window);
            XFlush(display);
            
            b32 HandlePopup = true;
            while (HandlePopup)
            {
                XEvent Event;
                XNextEvent(display, &Event);
                
                ButtonClicked = false;
                
                if (Event.type == MotionNotify)
                {
                    if ((ButtonX <= Event.xmotion.x) && (Event.xmotion.x < (ButtonX + ButtonWidth)) &&
                        (ButtonY <= Event.xmotion.y) && (Event.xmotion.y < (ButtonY + ButtonHeight)))
                    {
                        if (!ButtonActive) {
                            Event.type = Expose;
                        }
                        
                        ButtonActive = true;
                    }
                    else
                    {
                        if (ButtonActive) {
                            Event.type = Expose;
                        }
                        
                        ButtonActive = false;
                    }
                }
                
                switch (Event.type)
                {
                    case ButtonPress:
                    case ButtonRelease:
                    {
                        if (Event.xbutton.button != Button1)
                        {
                            break;
                        }
                        
                        if (ButtonActive)
                        {
                            ButtonClicked = (Event.type == ButtonPress) ? 1 : 0;
                            if (!ButtonClicked)
                            {
                                HandlePopup = false;
                            }
                        }
                    }
                    
                    case Expose:
                    case MapNotify:
                    {
                        XClearWindow(display, window);
                        
                        char *StartOfLine = Message;
                        s32 HeightOffset = 0;
                        while (*StartOfLine)
                        {
                            char *EndOfLine = StartOfLine;
                            while (*EndOfLine && !IsEndOfLine(*EndOfLine)) {
                                ++EndOfLine;
                            }
                            
                            XDrawString(display, window, GraphicsContext, 10, 10 + LineHeight + HeightOffset,
                                        StartOfLine, (u32)(EndOfLine - StartOfLine));
                            
                            HeightOffset += LineHeight;
                            
                            if (IsEndOfLine(*EndOfLine)) {
                                ++EndOfLine;
                            }
                            StartOfLine = EndOfLine;
                        }
                        
                        if (ButtonActive)
                        {
                            XFillRectangle(display, window, GraphicsContext,
                                           ButtonClicked + ButtonX, ButtonClicked + ButtonY,
                                           ButtonWidth, ButtonHeight);
                            XSetForeground(display, GraphicsContext, Black);
                            XSetBackground(display, GraphicsContext, White);
                        }
                        else
                        {
                            XSetForeground(display, GraphicsContext, White);
                            XSetBackground(display, GraphicsContext, Black);
                            XDrawRectangle(display, window, GraphicsContext,
                                           ButtonX, ButtonY, ButtonWidth, ButtonHeight);
                        }
                        
                        XDrawString(display, window, GraphicsContext,
                                    ButtonClicked + ButtonTextX, ButtonClicked + ButtonTextY,
                                    ButtonText, StringLength(ButtonText));
                        XSetForeground(display, GraphicsContext, White);
                        XSetBackground(display, GraphicsContext, Black);
                        XFlush(display);
                    } break;
                    
                    case KeyRelease:
                    {
                        if (XLookupKeysym(&Event.xkey, 0) == XK_Escape)
                        {
                            HandlePopup = false;
                        }
                        else if (XLookupKeysym(&Event.xkey, 0) == XK_Return)
                        {
                            HandlePopup = false;
                        }
                    } break;
                    
                    case ClientMessage:
                    {
                        if ((Atom)Event.xclient.data.l[0] == WmDelete)
                        {
                            HandlePopup = false;
                        }
                    } break;
                }
            }
        }
        else
        {
            fprintf(stderr, "Unable to load a X11 font while trying to display an error message\n");
            fprintf(stderr, "%s: %s\n", Caption, Message);
        }
        
        XFreeGC(display, GraphicsContext);
        XDestroyWindow(display, window);
        XFlush(display);
    }
    else
    {
        fprintf(stderr, "%s: %s\n", Caption, Message);
    }
    
    if (Type == PlatformError_Fatal)
    {
        exit(1);
    }
}


//
// NOTE(michiel): MAIN
//

#if HANDMADE_INTERNAL
global debug_table GlobalDebugTable_;
debug_table *GlobalDebugTable = &GlobalDebugTable_;
#endif

#if 0
// TODO(michiel): Linuxify
internal void
LinuxFullRestart(char *SourceEXE, char *DestEXE, char *DeleteEXE)
{
    
    pid_t Pid = fork();
    
    if (Pid)
    {
        Assert(sizeof(Result.OSHandle) >= sizeof(pid_t));
        *(pid_t *)&Result.OSHandle = Pid;
    }
    else
    {
        // NOTE(michiel): This is the created child process
        chdir(Path);
        execl(RealCommand, CommandLine, (char *)0);
        exit(0);
    }
    
    DeleteFile(DeleteEXE);
    if(MoveFile(DestEXE, DeleteEXE))
    {
        if(MoveFile(SourceEXE, DestEXE))
        {
            STARTUPINFO StartupInfo = {};
            StartupInfo.cb = sizeof(StartupInfo);
            PROCESS_INFORMATION ProcessInfo = {};
            if(CreateProcess(DestEXE,
                             GetCommandLine(),
                             0,
                             0,
                             FALSE,
                             0,
                             0,
                             "w:\\handmade\\data\\",
                             &StartupInfo,
                             &ProcessInfo))
            {
                CloseHandle(ProcessInfo.hProcess);
            }
            else
            {
                // TODO(casey): Error!
            }
            
            ExitProcess(0);
        }
    }
}
#endif

int main(int argc, char **argv)
{
    SetDefaultFPBehavior();
    
    DEBUGSetEventRecording(true);
    
    linux_state *State = &GlobalLinuxState;
    State->MemorySentinel.Prev = &State->MemorySentinel;
    State->MemorySentinel.Next = &State->MemorySentinel;
    
    LinuxGetEXEFileName(State);
    
    char LinuxEXEFullPath[LINUX_STATE_FILE_NAME_COUNT];
    LinuxBuildEXEPathFileName(State, "linux_handmade",
                              sizeof(LinuxEXEFullPath), LinuxEXEFullPath);
    
    char SourceGameCodeDLLFullPath[LINUX_STATE_FILE_NAME_COUNT];
    LinuxBuildEXEPathFileName(State, "libHandmade.so",
                              sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);
    
    char RendererCodeDLLFullPath[LINUX_STATE_FILE_NAME_COUNT];
    LinuxBuildEXEPathFileName(State, "libHandmadeOpenGL.so",
                              sizeof(RendererCodeDLLFullPath), RendererCodeDLLFullPath);
    
    XInitThreads();
    
    GlobalWindowPositionX = 0;
    GlobalWindowPositionY = 0;
    
#if HANDMADE_INTERNAL
    DEBUGGlobalShowCursor = true;
#endif
    
    /* Open Xlib Display */
    char *DefaultDisplay = getenv("DISPLAY");
    Display *display = 0;
    if (DefaultDisplay)
    {
        display = XOpenDisplay(DefaultDisplay);
    }
    
    if (!display)
    {
        // NOTE(michiel): Try again without a specific display
        display = XOpenDisplay(NULL);
    }
    
    if (display)
    {
        State->DefaultDisplay = display;
        
        v2u WindowStartSize = {1920, 1080};
        
        u32 MaxQuadCountPerFrame = (1 << 20);
        platform_renderer_limits Limits = {};
        Limits.MaxQuadCountPerFrame = MaxQuadCountPerFrame;
        Limits.MaxTextureCount = HANDMADE_NORMAL_TEXTURE_COUNT;
        Limits.MaxSpecialTextureCount = HANDMADE_SPECIAL_TEXTURE_COUNT;
        Limits.TextureTransferBufferSize = HANDMADE_TEXTURE_TRANSFER_BUFFER_SIZE;
        string Path =
        {
            (umm)(State->OnePastLastEXEFileNameSlash - State->EXEFileName),
            (u8 *)State->EXEFileName,
        };
        
        linux_renderer_function_table RendererFunctions = {};
        linux_loaded_code RendererCode = {};
        RendererCode.LibraryFullPath = RendererCodeDLLFullPath;
        RendererCode.FunctionCount = ArrayCount(LinuxRendererFunctionTableNames);
        RendererCode.FunctionNames = LinuxRendererFunctionTableNames;
        RendererCode.Functions = (void **)&RendererFunctions;
        
        LinuxLoadCode(State, &RendererCode);
        if (!RendererCode.IsValid)
        {
            LinuxErrorMessage(PlatformError_Fatal, "Unable to load renderer");
        }
        
        platform_renderer *Renderer = RendererFunctions.LoadRenderer(display, GlobalWindowPositionX, GlobalWindowPositionY,
                                                                     WindowStartSize.Width, WindowStartSize.Height, &Limits);
        // TODO(michiel): How to get the window after the renderer is finished
        linux_renderer *LinuxRender = (linux_renderer *)Renderer->Platform;
        Window RenderWindow = LinuxRender->window;
        
        if (RenderWindow)
        {
            XSizeHints SizeHints = {};
            SizeHints.x = GlobalWindowPositionX;
            SizeHints.y = GlobalWindowPositionY;
            SizeHints.width  = WindowStartSize.Width;
            SizeHints.height = WindowStartSize.Height;
            SizeHints.flags = USSize | USPosition; //US vs PS?
            
            XSetNormalHints(display, RenderWindow, &SizeHints);
            XSetStandardProperties(display, RenderWindow, "Handmade Hero", "glsync text", None, NULL, 0, &SizeHints);
            
            Atom WmDeleteWindow = XInternAtom(display, "WM_DELETE_WINDOW", False);
            XSetWMProtocols(display, RenderWindow, &WmDeleteWindow, 1);
            
            // NOTE(michiel): Hide cursor
            LinuxCreateHiddenCursor(display, RenderWindow);
#if HANDMADE_INTERNAL
            LinuxShowCursor(display, RenderWindow);
#else
            LinuxHideCursor(display, RenderWindow);
            ToggleFullscreen(display, RenderWindow);
#endif
            
            s32 NrProcessors = get_nprocs();
            // NOTE(michiel): Minus the main thread of course
            --NrProcessors;
            
            // NOTE(michiel): Get number of extra threads to use
            s32 HighPrioTasks = 1;
            s32 LowPrioTasks = 1;
            if (NrProcessors > 0)
            {
                HighPrioTasks = Maximum(1, (s32)((f32)NrProcessors * 0.8));
                LowPrioTasks = Maximum(1, NrProcessors - HighPrioTasks);
            }
            
            linux_thread_startup *HighPriStartups = (linux_thread_startup *)alloca(HighPrioTasks * sizeof(linux_thread_startup));
            for (u32 HighStartupIndex = 0;
                 HighStartupIndex < HighPrioTasks;
                 ++HighStartupIndex)
            {
                linux_thread_startup *ThreadStartup = HighPriStartups + HighStartupIndex;
                ZeroStruct(*ThreadStartup);
            }
            platform_work_queue HighPriorityQueue = {};
            LinuxMakeQueue(&HighPriorityQueue, HighPrioTasks, HighPriStartups);
            
            linux_thread_startup *LowPriStartups = (linux_thread_startup *)alloca(LowPrioTasks * sizeof(linux_thread_startup));
            for (u32 LowStartupIndex = 0;
                 LowStartupIndex < LowPrioTasks;
                 ++LowStartupIndex)
            {
                linux_thread_startup *ThreadStartup = LowPriStartups + LowStartupIndex;
                ZeroStruct(*ThreadStartup);
            }
            platform_work_queue LowPriorityQueue = {};
            LinuxMakeQueue(&LowPriorityQueue, LowPrioTasks, LowPriStartups);
            
            linux_sound_output SoundOutput = {};
            
            // TODO(michiel): Use XRandR only for this query?
            int MonitorRefreshHz = 60;
            f32 GameUpdateHz = (f32)(MonitorRefreshHz);
            
            if (LinuxInitializeSound("default", 48000, 4, 512, &SoundOutput))
            {
                LinuxStartPlayingSound();
                
                GlobalRunning = true;
                
                // TODO(casey): Let's make this our first growable arena!
                memory_arena FrameTempArena = {};
                
                // TODO(michiel): Pool with bitmap mmap
                // TODO(casey): Remove MaxPossibleOverrun?
                size_t NrSamples = SoundOutput.SamplesPerSecond * AUDIO_CHANNELS;     // 1 second
                size_t SampleSize = NrSamples * sizeof(s16);
                u32 MaxPossibleOverrun = AUDIO_CHANNELS * 8 * sizeof(u16);
                s16 *Samples = (s16 *)mmap(NULL, SampleSize + MaxPossibleOverrun,
                                           PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
                SoundOutput.SafetyBytes = (SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample / GameUpdateHz) / 3;
                
#if HANDMADE_INTERNAL
                void *BaseAddress = (void *)Terabytes((u64)2);
#else
                void *BaseAddress = 0;
#endif
                
                game_memory GameMemory = {};
#if HANDMADE_INTERNAL
                GameMemory.DebugTable = GlobalDebugTable;
#endif
                GameMemory.HighPriorityQueue = &HighPriorityQueue;
                GameMemory.LowPriorityQueue = &LowPriorityQueue;
                GameMemory.PlatformAPI.AddEntry = LinuxAddEntry;
                GameMemory.PlatformAPI.CompleteAllWork = LinuxCompleteAllWork;
                
                GameMemory.PlatformAPI.GetAllFilesOfTypeBegin = LinuxGetAllFilesOfTypeBegin;
                GameMemory.PlatformAPI.GetAllFilesOfTypeEnd = LinuxGetAllFilesOfTypeEnd;
                GameMemory.PlatformAPI.OpenFile = LinuxOpenFile;
                GameMemory.PlatformAPI.GetFileByPath = LinuxGetFileByPath;
                GameMemory.PlatformAPI.SetFileSize = LinuxSetFileSize;
                GameMemory.PlatformAPI.ReadDataFromFile = LinuxReadDataFromFile;
                GameMemory.PlatformAPI.WriteDataToFile = LinuxWriteDataToFile;
                GameMemory.PlatformAPI.FileError = LinuxFileError;
                GameMemory.PlatformAPI.AtomicReplaceFileContents = LinuxAtomicReplaceFileContents;
                GameMemory.PlatformAPI.CloseFile = LinuxCloseFile;
                
                GameMemory.PlatformAPI.AllocateMemory = LinuxAllocateMemory;
                GameMemory.PlatformAPI.DeallocateMemory = LinuxDeallocateMemory;
                GameMemory.PlatformAPI.ErrorMessage = LinuxErrorMessage;
                
#if HANDMADE_INTERNAL
                GameMemory.PlatformAPI.DEBUGExecuteSystemCommand = DEBUGExecuteSystemCommand;
                GameMemory.PlatformAPI.DEBUGGetProcessState = DEBUGGetProcessState;
                GameMemory.PlatformAPI.DEBUGGetMemoryStats = LinuxGetMemoryStats;
#endif
                GameMemory.TextureQueue = &Renderer->TextureQueue;
                Platform = GameMemory.PlatformAPI;
                
                if (Samples != MAP_FAILED)
                {
                    u32 NrJoysticks = LinuxFindJoysticks();
                    
                    game_input Input[2] = {};
                    game_input *NewInput = &Input[0];
                    game_input *OldInput = &Input[1];
                    
                    struct timespec LastCounter = LinuxGetWallClock();
                    struct timespec FlipWallClock = LinuxGetWallClock();
                    
                    int DebugTimeMarkerIndex = 0;
                    linux_debug_time_marker DebugTimeMarkers[30] = {0};
                    
                    u32 AudioLatencyBytes = 0;
                    f32 AudioLatencySeconds = 0.0f;
                    b32 SoundIsValid = false;
                    
                    linux_game_function_table Game = {};
                    linux_loaded_code GameCode = {};
                    GameCode.LibraryFullPath = SourceGameCodeDLLFullPath;
                    GameCode.FunctionCount = ArrayCount(LinuxGameFunctionTableNames);
                    GameCode.FunctionNames = LinuxGameFunctionTableNames;
                    GameCode.Functions = (void **)&Game;
                    
                    LinuxLoadCode(State, &GameCode);
                    
                    DEBUGSetEventRecording(GameCode.IsValid);
                    
                    // NOTE(michiel): And display the window on the screen
                    XMapRaised(display, RenderWindow);
                    b32x RendererWasReloaded = false;
                    u32 ExpectedFramesPerUpdate = 1;
                    f32 TargetSecondsPerFrame = (f32)ExpectedFramesPerUpdate / (f32)GameUpdateHz;
                    
                    // NOTE(michiel): Querying X11 every frame can cause hickups because of a sync of X11 state
                    v2u Dimension = LinuxGetWindowDimension(display, RenderWindow);
                    v2 MouseP = LinuxGetMousePosition(display, RenderWindow);
                    
                    while (GlobalRunning)
                    {
                        {DEBUG_DATA_BLOCK("Platform");
                            DEBUG_VALUE(ExpectedFramesPerUpdate);
                        }
                        {DEBUG_DATA_BLOCK("Platform/Controls");
                            DEBUG_B32(GlobalPause);
                            DEBUG_B32(GlobalSoftwareRendering);
                        }
                        
                        //
                        //
                        //
                        
                        NewInput->dtForFrame = TargetSecondsPerFrame;
                        
                        //
                        //
                        //
                        
                        BEGIN_BLOCK("Input Processing");
                        
                        // TODO(casey): Zeroing macro
                        // TODO(casey): We can't zero everything because the up/down state will
                        // be wrong!!!
                        game_controller_input *OldKeyboardController = GetController(OldInput, 0);
                        game_controller_input *NewKeyboardController = GetController(NewInput, 0);
                        {
                            TIMED_BLOCK("Resetting Buttons");
                            *NewKeyboardController = {};
                            NewKeyboardController->IsConnected = true;
                            for(u32 ButtonIndex = 0;
                                ButtonIndex < ArrayCount(NewKeyboardController->Buttons);
                                ++ButtonIndex)
                            {
                                NewKeyboardController->Buttons[ButtonIndex].EndedDown =
                                    OldKeyboardController->Buttons[ButtonIndex].EndedDown;
                            }
                            for(u32 ButtonIndex = 0;
                                ButtonIndex < PlatformMouseButton_Count;
                                ++ButtonIndex)
                            {
                                NewInput->MouseButtons[ButtonIndex] = OldInput->MouseButtons[ButtonIndex];
                                NewInput->MouseButtons[ButtonIndex].HalfTransitionCount = 0;
                            }
                            
                            NewInput->AltDown = OldInput->AltDown;
                            NewInput->ShiftDown = OldInput->ShiftDown;
                            NewInput->ControlDown = OldInput->ControlDown;
                        }
                        
                        {
                            TIMED_BLOCK("Linux Keyboard and Message Processing");
                            ZeroStruct(NewInput->FKeyPressed);
                            LinuxProcessPendingMessages(State, display, RenderWindow, WmDeleteWindow,
                                                        NewKeyboardController, NewInput, &MouseP, &Dimension);
                        }
                        
                        /* NOTE(casey): 1080p display mode is 1920x1080 -> Half of that is 960x540
                           1920 -> 2048 = 2048-1920 -> 128 pixels
                           1080 -> 2048 = 2048-1080 -> pixels 968
                           1024 + 128 = 1152
                        */
                        v2u RenderDim =
                        {
                            // 192, 108,
                            // 480, 270,
                            // 960, 540,
                            // 1280, 720,
                            // 1279, 719,
                            
                            1920, 1080
                        };
                        rectangle2i DrawRegion = AspectRatioFit(RenderDim.Width, RenderDim.Height,
                                                                Dimension.Width, Dimension.Height);
                        
                        game_render_commands *Frame = 0;
                        if (RendererCode.IsValid)
                        {
                            Frame = RendererFunctions.BeginFrame(
                                                                 Renderer, Dimension, RenderDim, DrawRegion);
                        }
                        
                        {
                            TIMED_BLOCK("Mouse Position");
                            f32 MouseX = (f32)MouseP.x;
                            f32 MouseY = (f32)((Dimension.Height - 1) - MouseP.y);
                            
                            NewInput->ClipSpaceMouseP.x =  ClampBinormalMapToRange((f32)DrawRegion.MinX, MouseX, (f32)DrawRegion.MaxX);
                            NewInput->ClipSpaceMouseP.y = ClampBinormalMapToRange((f32)DrawRegion.MinY, MouseY, (f32)DrawRegion.MaxY);
                            NewInput->ClipSpaceMouseP.z = 0.0f;
                        }
                        
                        if (!GlobalPause)
                        {
                            TIMED_BLOCK("Joystick processing");
                            // set the third parameter to the start where to fill in joystick data
                            LinuxJoystickPopulateGameInput(NewInput, OldInput, 1, NrJoysticks);
                        }
                        END_BLOCK();
                        
                        //
                        //
                        //
                        
                        BEGIN_BLOCK("Game Update");
                        
                        if(Frame && !GlobalPause)
                        {
                            if(State->InputRecordingIndex)
                            {
                                LinuxRecordInput(State, NewInput);
                            }
                            
                            if(State->InputPlayingIndex)
                            {
                                game_input Temp = *NewInput;
                                LinuxPlayBackInput(State, NewInput);
                                for(u32 MouseButtonIndex = 0;
                                    MouseButtonIndex < PlatformMouseButton_Count;
                                    ++MouseButtonIndex)
                                {
                                    NewInput->MouseButtons[MouseButtonIndex] = Temp.MouseButtons[MouseButtonIndex];
                                }
                                NewInput->ClipSpaceMouseP = Temp.ClipSpaceMouseP;
                            }
                            if(Game.UpdateAndRender)
                            {
                                Game.UpdateAndRender(&GameMemory, NewInput, Frame);
                                if(NewInput->QuitRequested)
                                {
                                    GlobalRunning = false;
                                }
                            }
                        }
                        
                        END_BLOCK();
                        
                        //
                        //
                        //
                        
                        BEGIN_BLOCK("Audio Update");
                        
                        if(!GlobalPause)
                        {
                            /* NOTE(casey):
                            
                               Here is how sound output computation works.
                               
                               We define a safety value that is the number
                               of samples we think our game update loop
                               may vary by (let's say up to 2ms)
                               
                               When we wake up to write audio, we will look
                               and see what the play cursor position is and we
                               will forecast ahead where we think the play
                               cursor will be on the next frame boundary.
                               
                               We will then look to see if the write cursor is
                               before that by at least our safety value.  If
                               it is, the target fill position is that frame
                               boundary plus one frame.  This gives us perfect
                               audio sync in the case of a card that has low
                               enough latency.
                               
                               If the write cursor is _after_ that safety
                               margin, then we assume we can never sync the
                               audio perfectly, so we will write one frame's
                               worth of audio plus the safety margin's worth
                               of guard samples.
                            */
                            u32 PlayCursor = SoundOutput.Buffer.ReadIndex;
                            u32 WriteCursor = PlayCursor + AUDIO_WRITE_SAFE_SAMPLES * SoundOutput.BytesPerSample;
                            if (!SoundIsValid)
                            {
                                SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
                                SoundIsValid = true;
                            }
                            
                            u32 ByteToLock = ((SoundOutput.RunningSampleIndex*SoundOutput.BytesPerSample) %
                                              SoundOutput.Buffer.Size);
                            
                            u32 ExpectedSoundBytesPerFrame =
                                (u32)((f32)(SoundOutput.SamplesPerSecond*SoundOutput.BytesPerSample) * TargetSecondsPerFrame);
                            
                            u32 ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
                            
                            u32 SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
                            b32 AudioCardIsLowLatency = (SafeWriteCursor < ExpectedFrameBoundaryByte);
                            
                            u32 TargetCursor = 0;
                            if(AudioCardIsLowLatency)
                            {
                                TargetCursor = (ExpectedFrameBoundaryByte + ExpectedSoundBytesPerFrame);
                            }
                            else
                            {
                                TargetCursor = (WriteCursor + ExpectedSoundBytesPerFrame +
                                                SoundOutput.SafetyBytes);
                            }
                            TargetCursor = (TargetCursor % SoundOutput.Buffer.Size);
                            
                            u32 BytesToWrite = 0;
                            if(ByteToLock > TargetCursor)
                            {
                                BytesToWrite = (SoundOutput.Buffer.Size - ByteToLock);
                                BytesToWrite += TargetCursor;
                            }
                            else
                            {
                                BytesToWrite = TargetCursor - ByteToLock;
                            }
                            
                            game_sound_output_buffer SoundBuffer = {};
                            SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
                            SoundBuffer.SampleCount = Align8(BytesToWrite / SoundOutput.BytesPerSample);
                            BytesToWrite = SoundBuffer.SampleCount*SoundOutput.BytesPerSample;
                            SoundBuffer.Samples = Samples;
                            if(Game.GetSoundSamples)
                            {
                                Game.GetSoundSamples(&GameMemory, &SoundBuffer);
                            }
                            
#if HANDMADE_INTERNAL
                            linux_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
                            Marker->OutputPlayCursor = PlayCursor;
                            Marker->OutputWriteCursor = WriteCursor;
                            Marker->OutputLocation = ByteToLock;
                            Marker->OutputByteCount = BytesToWrite;
                            Marker->ExpectedFlipPlayCursor = ExpectedFrameBoundaryByte;
                            
                            u32 UnwrappedWriteCursor = WriteCursor;
                            if(UnwrappedWriteCursor < PlayCursor)
                            {
                                UnwrappedWriteCursor += SoundOutput.Buffer.Size;
                            }
                            AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
                            AudioLatencySeconds =
                                (((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / (f32)SoundOutput.SamplesPerSecond);
#endif
                            LinuxFillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);
                        }
                        
                        END_BLOCK();
                        
                        //
                        // NOTE(casey): Output statistics to the debug view
                        //
                        
                        {DEBUG_DATA_BLOCK("Renderer");
                            DEBUG_VALUE(Renderer->TotalFramebufferMemory);
                            DEBUG_VALUE(Renderer->TotalTextureMemory);
                            DEBUG_VALUE(Renderer->UsedMultisampleCount);
                        }
                        
                        //
                        //
                        //
                        
#if HANDMADE_INTERNAL
                        BEGIN_BLOCK("Debug Collation");
                        
                        // Reload code if necessary
                        b32 ExecutableNeedsToBeReloaded = LinuxCheckForCodeChange(&GameCode);
                        
                        GameMemory.ExecutableReloaded = false;
                        if(ExecutableNeedsToBeReloaded)
                        {
                            LinuxCompleteAllWork(&HighPriorityQueue);
                            LinuxCompleteAllWork(&LowPriorityQueue);
                            DEBUGSetEventRecording(false);
                        }
                        
                        if(Game.DEBUGFrameEnd)
                        {
                            Game.DEBUGFrameEnd(&GameMemory, NewInput, Frame);
                        }
                        
                        if(ExecutableNeedsToBeReloaded)
                        {
                            LinuxReloadCode(State, &GameCode);
                            GameMemory.ExecutableReloaded = true;
                            DEBUGSetEventRecording(GameCode.IsValid);
                        }
                        
                        END_BLOCK();
#endif
                        
                        //
                        //
                        //
                        
#if 0
                        BEGIN_BLOCK("Framerate Wait");
                        
                        if (!GlobalPause)
                        {
                            struct timespec WorkCounter = LinuxGetWallClock();
                            f32 WorkSecondsElapsed = LinuxGetSecondsElapsed(LastCounter, WorkCounter);
                            
                            f32 SecondsElapsedForFrame = WorkSecondsElapsed;
                            if (SecondsElapsedForFrame < TargetSecondsPerFrame)
                            {
                                u32 SleepUs = (u32)(0.99e6f * (TargetSecondsPerFrame - SecondsElapsedForFrame));
                                usleep(SleepUs);
                                while (SecondsElapsedForFrame < TargetSecondsPerFrame)
                                {
                                    SecondsElapsedForFrame = LinuxGetSecondsElapsed(LastCounter, LinuxGetWallClock());
                                }
                            }
                            else
                            {
                                // Missed frame rate
                            }
                        }
                        END_BLOCK();
#endif
                        
                        //
                        //
                        //
                        
                        BEGIN_BLOCK("Frame Display");
                        
                        if (RendererCode.IsValid)
                        {
                            if (RendererWasReloaded)
                            {
                                ++Frame->Settings.Version;
                                RendererWasReloaded = false;
                            }
                            RendererFunctions.EndFrame(Renderer, Frame);
                        }
                        
                        if (LinuxCheckForCodeChange(&RendererCode))
                        {
                            LinuxReloadCode(State, &RendererCode);
                            RendererWasReloaded = true;
                        }
                        
                        FlipWallClock = LinuxGetWallClock();
                        
                        game_input *Temp = NewInput;
                        NewInput = OldInput;
                        OldInput = Temp;
                        // TODO(casey): Should I clear these here?
                        
                        END_BLOCK();
                        
                        struct timespec EndCounter = LinuxGetWallClock();
                        f32 MeasuredSecondsPerFrame = LinuxGetSecondsElapsed(LastCounter, EndCounter);
                        f32 ExactTargetFramesPerUpdate = MeasuredSecondsPerFrame*(f32)MonitorRefreshHz;
                        u32 NewExpectedFramesPerUpdate = RoundReal32ToInt32(ExactTargetFramesPerUpdate);
                        ExpectedFramesPerUpdate = NewExpectedFramesPerUpdate;
                        
                        TargetSecondsPerFrame = MeasuredSecondsPerFrame;
                        
                        FRAME_MARKER(MeasuredSecondsPerFrame);
                        LastCounter = EndCounter;
                    }
                    
                    LinuxCompleteAllWork(&HighPriorityQueue);
                    LinuxCompleteAllWork(&LowPriorityQueue);
                    
                    LinuxUnloadCode(&GameCode);
                    LinuxStopPlayingSound();
                }
                else
                {
                    LinuxStopPlayingSound();
                    LinuxErrorMessage(PlatformError_Fatal, "Unable to allocate memory for the sound output.");
                }
            }
            else
            {
                LinuxErrorMessage(PlatformError_Fatal, "Unable to initialize sound.");
            }
        }
        else
        {
            LinuxErrorMessage(PlatformError_Fatal, "Unable to open game window.");
        }
    }
    else
    {
        LinuxErrorMessage(PlatformError_Fatal, "Unable to open X11 display.");
    }
    
    return 0;
}
© 2021 GitHub, Inc.
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
Loading complete
