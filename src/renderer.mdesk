Color :: struct
{
    r: u8, 
    g: u8, 
    b: u8, 
    a: u8, 
}


Vertex :: struct
{
    position: vec3,
    uv: vec2,
    color: Color,
    texture_slot: f32,
}

Vertex3D :: struct
{
    position: vec3,
    normal: vec3,
    uv: vec2,
    //color: Color,
    texture_slot: f32,
}


@Print
Camera :: struct
{
    position: vec3,
    direction: vec3,
    up: vec3,
}

SpriteType :: enum
{
    TYPE_SPRITE,
    TYPE_SUBSPRITE,
}

@Print
Sprite :: struct
{
    main_sprite: u32,
    @NoPrint
        uvs: [4]vec2,
    name: *char,
    data: *void,
    width: i32,
    height: i32,
    channels: i32,
    
    id: u32,
    slot: u32,
    type: SpriteType,
}


CharMetric :: struct
{
    x0: u16,
    y0: u16,
    x1: u16,
    y1: u16,
    xoff: f32,
    yoff: f32,
    xadvance: f32,
}

TextAlign :: enum
{
    TEXT_ALIGN_MIDDLE,
    TEXT_ALIGN_LEFT,
}

Font :: struct
{
    sprite_handles: *u32,
    char_metrics: *CharMetric,
    num_chars: u16,
    font_size: u32,
    font_sprite_handle: u32,
}



RenderEntryType :: enum
{
    RENDER_ENTRY_QuadEntry,
    RENDER_ENTRY_TriangleEntry,
    RENDER_ENTRY_Model,
}

RenderEntryHeader :: struct
{
    entry_type: RenderEntryType,
}

ShaderId :: enum
{
    SHADER_ID_NORMAL,
    SHADER_ID_HUE_QUAD,
    SHADER_ID_SB_QUAD,
    SHADER_ID_BASIC_3D,
    NUM_SHADERS,
}

QuadEntry :: struct
{
    position: vec3,
    size: vec2,
    color: Color,
    sprite_handle: u32,
    
    shader_id: ShaderId,
}

TriangleEntry :: struct
{
    points: [3]vec3,
    color: Color,
    sprite_handle: u32,
    
    shader_id: ShaderId,
}

SortElement :: struct
{
    entry_offset: u32,
    key: u32,
}

RenderSetup :: struct
{
    projection: mat4,
    camera: Camera,
}

UniformType :: enum
{
    UNIFORM_F32,
    UNIFORM_F64,
    UNIFORM_I32,
    UNIFORM_U32,
    UNIFORM_VEC2,
    UNIFORM_VEC3,
    UNIFORM_VEC4,
    UNIFORM_MAT4,
    UNIFORM_TEXTURE2D,
}

UniformTypeInfo :: struct
{
    type: UniformType,
    size: u32,
}

Uniform :: struct
{
    type_info: UniformTypeInfo,
    data: *void,
    name: *char,
    
    next: *Uniform;
}


Shader :: struct
{
    bind_id: u32,
    uniforms: *Uniform,
    num_uniforms: i32,
}

AssetType :: enum
{
    SPRITE_ASSET,
    MODEL_ASSET,
    SOUND_ASSET,
}

Assets :: struct
{
    arena: MemoryArena,
    
    loaded_sprite_queue: *u32,
    num_queued_sprites: u32,
    
    sprites: *Sprite,
    num_sprites: u32,
    
    shaders: [NUM_SHADERS]Shader,
}


RenderGroup :: struct
{
    setup: RenderSetup,
    assets: *Assets,
    
    push_buffer_base: *u8,
    push_buffer_size: u32,
    push_buffer_capacity: u32,
    
    sort_element_count: u32,
}

Light :: struct
{
    ambient: vec3,
    diffuse: vec3,
    specular: vec3,
    
    position: vec3,
}

Material :: struct
{
    ambient: vec3,
    diffuse: vec3,
    specular: vec3,
    
    shininess: f32,
}

Mesh :: struct
{
    vertices: *Vertex3D,
    num_vertices: u32,
    
    indices: *u32,
    num_indices: u32,
    
    
    material: Material,
    
    VAO: u32,
    EBO: u32,
    VBO: u32,
}

MAX_VERTICES :: 100000
MAX_INDICES :: 150000

Renderer2D :: struct
{
    vertices: [MAX_VERTICES]Vertex,
    vertex_count: u32,
    indices: [MAX_INDICES]u32,
    indices_count: u32,
    
    VBO: u32,
    EBO: u32,
    VAO: u32,
    
    slot: u32,
    
    screen_width: i32,
    screen_height: i32,
    
    assets: *Assets,
    
    render_groups: [10]RenderGroup,
    render_group_count: u32,
    
    white_sprite: u32,
    
    mesh: Mesh,
    camera: *Camera,
    light: Light,
    shader_program_3D: u32,
}

